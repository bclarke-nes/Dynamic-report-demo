---
title: "![](https://i.imgur.com/5EhpPqK.png) Producing dynamic reports"
date: "`r Sys.time()`"
subtitle: "Demonstration"
output:
  html_document:
    toc: no
    toc_depth: 2
    number_sections: no
    toc_float:
      collapsed: no
  word_document:
    toc: yes
    toc_depth: '2'
  pdf_document:
    toc: yes
    toc_depth: '2'
    pandoc_args: ["--extract-media", "."]
---
# Introduction{.tabset}
This is our dynamic report training resource. The main objective of this training resource is to demonstrate how to build a report like this one. In this session, we will work through the report step-by-step. It's interactive - so do please ask questions, or for extra clarification if anything isn't as clear as you'd like it to be. It's also very useful for everyone in the group if you can reflect on how this demonstration report might be adapted to suit your needs.

Most of this demonstration is just about following-along. It's useful to try and switch between the code pane and the viewer pane to see how the report works. You might find it helpful to minimise the Console and Environment panes for this tutorial as they're less important at this stage.

### What to do if things go wrong?
There are lots of minor problems that we might encounter while working through this report. First, this is *normal and to be expected*. Please don't worry if things don't work first time - we will be able to work through any problems that you might encounter and hopefully resolve them fairly easily. Second, we'll give some advice below about good strategies for solving problems - this is a key part of the learning journey in this field.

## Getting set-up
First thing first: we will work through knitting this document at the start of the session. We definitely don't want our end users to see our RMarkdown code. So the .Rmd file that we are working on needs to be converted into a suitable output format. We call that conversion *knitting* (after the R package `knitr` that manages the conversion). To knit your file, you can either:

- select the Knit option from the menu at the top of the code pane. You can select any of the output formats, although I'd suggest sticking with .html (webpage) while working through the demo. ![](https://i.imgur.com/HhM3NqK.png)
- alternatively, press `ctrl+shift+k` while your cursor is in the code pane to knit to the last used format

Knitting is controlled by the preamble at the head of .Rmd. For now, I'll suggest that you skip trying to figure it all out in favour of spending our time on some of the more interesting areas of this demonstration. I'll give more details about setting up your Rmarkdown document at the end of this document in the **More details** section.

The first time that you knit your document in RStudio Cloud, you may get a warning about required packages. Just agree to this, as you'll need the packages to knit your document properly.
![](https://i.imgur.com/6pfFbXk.png)

### Getting R ready
Once you've got the header in place, we need to do a tiny bit of setting R up properly. R uses packages, which are plug-ins that offer useful functions. We need to add these packages to R to help us do some of the tasks in this demonstration. We'll add them in the chunk of R code below:

```{r setup, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
  library(tidyverse)
  library(lubridate)
  library(NHSRplotthedots)
  library(readxl)
  # library(tidyr)
  # library(readr)
  # library(DiagrammeR)
  # library(ggplot2)
  # library(dplyr)


# There's a problem currently with RStudio Cloud and tidyverse. If tidyverse installation fails, we'll need to install five packages individually. If that's the case, comment out the `library(tidyverse)` line by adding a # at the start of the line. Then uncomment, by removing the #s, the five lines installing tidyr, readr, DiagrammeR, ggplot2, and dplyr. You'll then need to install the packages, following the instructions in the demonstration report but using a different list of packages for installation as follows:

#                                 tidyr,readr,DiagrammeR,ggplot2,dplyr,lubridate,NHSRplotthedots,readxl

# Also comments are useful - add comments as you work! R comments start with a #, comments in RMarkdown start <!-- and end -->

```

We load several packages (link to eventual NHS-R statement on tools and packages) here to help us do some useful work with our data. These are all *very* useful for health and care projects, so we'll briefly introduce them here:

+ [tidyverse](https://www.tidyverse.org/) - this is a large ecosystem of tools designed for data science. Specifically in this demonstration, we use tidyr, readr, DiagrammeR, ggplot2, and dplyr. We also use readxl to open Excel files
+ [lubridate](https://lubridate.tidyverse.org/) - helps with handling dates and times
+ [NHSRplotthedots](https://github.com/nhs-r-community/NHSRplotthedots)  - NHS-R community tool for making XmR charts

You may need to install some or all of these packages. You should do this by:
1. navigating to `Tools >> Install Packages'
![](https://i.imgur.com/f93MaFt.png)

2. pasting the following list of packages into the box: ```tidyverse,lubridate,NHSRplotthedots```
3. if there are problems, please refer to the note in the code for this section 

## Using Rmarkdown

[Rmarkdown](http://rmarkdown.rstudio.com) is a simple markup language. You might have used it before without really knowing what it was called. If you've ever posted on a Wordpress site or web forum with basic text formatting options available, the chances are that you've already done at least a tiny bit of markdown. Just to give you an example, surrounding a word with asterisks - like ```*italics*``` formats it in *italics*. Pairs of asterisks either side of the word formats that word - like ```**bold**``` - formats the text as **bold**. And so on. 

This kind of very basic formatting is known as Markdown. While it's simple, it's usually sufficient to allow the production of neat and clear documents that are easy to ready. Rmarkdown is just Markdown with a few extras to allow you to embed R code directly into the text that you're writing. That R code allows you to do more-or-less any data analysis that you might like and include the results in your markdown-formatted document. There's a quick reference sheet at the foot of this section.

### Suggested exercises

1. Change the image above to something less dull (like https://i.imgur.com/RkMmLXm.png)
2. Change THIS TEXT to bold, and THIS TEXT to italic
3. Add some bullet points below here describing your morning

Do have a look at the Rmarkdown in the code pane, and feel free to play around with it. Once you've had a look at some of the Rmarkdown in practice, we're ready to move on to get some data.

### RMarkdown quick reference

*italics*: ```*italics*```

**bold**: ```**bold**```

[links](https://google.com): ```[links](https://google.com)```

Heading levels

```
# Level 1
## Level 2
### Level 3
...

```

```![Linking images](https://i.imgur.com/5EhpPqK.png)```
![Linking images](https://i.imgur.com/5EhpPqK.png)

```
- dashes at the start of lines make bullet-points
- like so
```
- dashes at the start of lines make bullet-points
- like so

```
1. Numbers at the start of lines make numbered lists
2. like so
```
1. Numbers at the start of lines make numbered lists
2. Like so

## Getting data

Once we've got a sense of how we're going to write our report using RMarkdown, it's time to start thinking about the data that we are going to use to make our report update. Luckily, getting data into R is easy. Instead of opening a data file directly (as we might when using Excel), and then inspecting and analysing it, we instead load all the data in that file into R. 

I've provided some demo data, which you can see in the file pane (demo.csv). The format of this data is pretty simple: it gives three different values each measured on a single date as shown below. This might be similar to the kind of data that you'd see in your work - like admissions figures, service engagement statistics, or inquiry measures.

| date       | count1 | count2 | count3 |
| ---------- |:------:|:------:|:------:|
| 01/05/2022 |   11   |   93   |   82   |
| 02/05/2022 |   15   |   114  |   99   | 
| 03/05/2022 |   ...  |   ...  |   ...  |

We load the data using the following command:

```{r get data, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo <- read_csv("demo.csv")
```
Definitely worth us pausing here to explain what all this means. Usually in R, you do things by applying *commands* to objects like data. To break this command down into steps:

+ ```read_csv``` is the main command, which opens a .csv data file, and reads its contents
+ ```demo.csv``` is where we well `read.csv` which .csv file to open by specifying the file's path
+ ```<-``` then assigns the data that `read_csv` pulls out of the file to...
+ ```demo``` - the *tibble* that contains our data. We'll explain what a tibble is below, but for now you can just think of it as the way that R stores data

If you look at the code pane, you'll see that this R command is wrapped-up in backticks, with a lot of options in {curly brackets}. This is a way of marking our R code, and telling RStudio Cloud that we want it to be intpreted as R, rather than RMarkdown. We call these ```chunks```. In what's ahead, one of the most common problems come from chunks, and so one of the first things to check if a command doesn't work as expected is that it's properly in place in a chunk.

Because there are lots of different types of data out there, there are lots of ways of loading data into R. ```read_csv``` is the most commonly-used one, because .csv files - **c**omma **s**eparated **v**alues - are widely used to share data. The other main function used to load data is readr's ```read_excel```, which works similarly to ```read_csv```. 

Let's try a couple of tasks now to help you get the hang of loading data. There are two empty R chunks below. Can you fill in the gaps to make the right thing happen?

### Data exercise 1
Can you load the data from the data.csv file into a tibble called ```demo2```?

```{r data ex1, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Write your code in the line below. Hint: the structure of the command will be the same as the chunk above - but the name of the tibble will be different


```

### Data exercise 2
Can you load the data from the data2.xlsx file into the ```demo2``` tibble using read_excel?

```{r data ex2, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Write your code in the line below. This will overwrite the contents of demo2 with new data.



# Hint: whenever you're in a chunk, you can get help on a command by typing a question mark, then the name of the command, then ctrl-enter. For example, you can type ?read_excel on a new line for help with reading .xlsx files.
```

Once we've loaded our data, we can use it in other commands. One of the most useful commands is `head()`, which lets us look at the first few rows of a data object:

```{r inspect data 1, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
head(demo)
```

### Data exercise 3
Can you look at the head of your `demo2` tibble? How do demo and demo2 differ?

```{r data ex3, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Write your code in the line below

```

### A note on tibbles
From the .csv file, we have converted the data into a *tibble*, which is the name for the data structure used by the package ```tidyverse```. In this tibble (called ```demo```), each row contains four columns. One holds date, and the remaining three hold of counts of some imagined values from those dates. 

There's potentially lots to say about tibbles. If this is new territory for you, the [relevant chapter in *R for Data Science*](https://r4ds.had.co.nz/tibbles.html) is a great place to start. Or if you'd prefer something much more terse, the high-level introduction on the [tidyverse site](https://tibble.tidyverse.org/) would be good too.

### Back to our data

Once we've loaded our data, we can begin to do all kinds of interesting things with it. Most of that will have to wait for the section after next - we'll need to do some data tidying first before we can do most of the really interesting work. But just to whet your appetite, here are a couple of examples of operations that we can do on our data.

A common finding that we often need to report in data-driven work is about length. Just how many dates do we have data for? Happily, this is one of the easiest things to discover using R, because we can count the total number of rows in our tibble using the the `nrow()` command:

```{r inspect data 2, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
nrow(demo)
```
### Data exercise 4
Does `demo2` have the same number of rows as `demo`?

```{r data ex4, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Write your code in the line below

```


Or we can pull out the column headings with:
```{r inspect data 3, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
colnames(demo)
```

### Data exercise 5
Again, does `demo2` have the same column headings as `demo`?

```{r data ex5, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Write your code in the line below

```
Note that in the couple of examples above, we've just asked R to show us the number of rows/column names. We can also save these findings, which we might do if we want to use them later for another purpose. Just for instance, we can make a new variable *demo_length* containing the number of rows in data with:

```{r inspect data 4, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
demo_length <- nrow(demo)
```

And we can refer back to the value of *demo_length* whenever we like:
```{r inspect data 5, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
demo_length
```

Or do things to that value - like multiplying it by five:
```{r inspect data 6, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
demo_length * 5
```

### Data exercise 6
Can you calculate and display the difference in length between `demo` and `demo2`?

```{r data ex6, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Write your code in the line below

```

We can also create new variables from more complicated operations on our original tibble. For instance, we can extract a whole column using ```tibble$column```, and then add all the entries in that variable together using ```sum()```:

```{r inspect data 7, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
sum_count3 <- sum(demo$count3)
sum_count3
```
I think that's enough demonstrating the basics of loading data for now. There's one an important problem with our `demo` tibble: our dates aren't proper dates yet. `read_csv` doesn't know that the values in the date column actually are dates. We can tell that by looking `head(demo)`, which shows that the type of data in the `date` column is `<<chr>>`. This stands for `character`, which is the way that R refers to text values. We definitely want those values to be stored properly as dates, and doing that conversion will be the next part of this demonstration.

## Cleaning data

Time for another R chunk:

```{r clean up data, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo_dates <- demo %>% mutate(date = dmy(date))
```

There's a bit to unpack here. It makes most sense (to my mind, at least) to read this code backwards. From right to left, then:

+ ```dmy(date)```  is a lubridate command which takes whatever's in the bracket, and tries to convert it into a proper date. It works by assuming that it'll be a day value (d), followed by a month (m), followed by a year (y). There are also related commands like ```ymd()``` to be used when the dates given in our data are formatted differently.
+ `mutate(date =...)` takes the result of the `dmy()` above, and uses it in a command named `mutate`. `mutate` makes new columns in tibbles from existing columns. Here, we tell `mutate` to make a new column called `date` by taking the result of the `dmy(date)` above.
+ ` %>%` [the pipe!](https://r4ds.had.co.nz/pipes.html) This is a way of chaining commands together. In this case, writing `demo %>% mutate...` tells R to take the demo tibble, and do the mutate command to it. The advantage here is that we can string several `%>%`s together, to do many operations in sequence on some set of data.
+ finally, we assign the modified demo tibble to a new tibble `demo_dates` using `<-`.

That simple exercise introduces several new concepts, so we'll pause here to work through some exercises to reinforce the new material.

### Exercise 1

Let's take our `demo2` tibble, and inspect its `head()` to see what type of data is stored in it to find out whether or not we'll need to modify the date column in the same way:

```{r clean ex 1, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}

```

### Other major clean-ups

#### Missing and incorrect data

Sometimes we'll have missing or anomalous data in the files that we load into R. This can cause all kinds of subtle problems in R. Our `demo` tibble (and derivatives like `demo_dates` etc) have no missing data, so to demonstrate we'll load some new, faulty data into `demo3`, and try to tidy it up. The first part of this should be very familiar - we load data using `read_csv()`, then mutate the date column to give us proper dates. We then look at the `head()` of the data:

```{r clean 2, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo3 <- read_csv("demo3.csv") %>% mutate(date = dmy(date)) 
head(demo3)
```
Right away we can see a few problems:

- there's missing data in the count1 column (`NA`)
- the count2 column is `<chr>`, rather than `<dbl>` - *double* is R's way of referring to numeric data
- the title of the last column seems to have gotten scrambled

Let's deal with the missing data. Let's see what we're dealing with:

```{r clean 3, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo3 %>% filter(if_any(c(date, count1, count2, cnont3), ~ is.na(.)))

```
Don't worry too much about the details of the code above. We're just looking through `demo3` using the `filter` command, which shows rows that match some condition. We tell `filter` to look across the date, count1, count2, and count3 columns using `if_any`, and then specify that `filter` should look for any rows with missing data using `is.na`. We could also do this one column at a time:

```{r clean 4, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo3 %>% filter(is.na(date))

```

##### Exercise 2

Using the code above as a starting point, can you confirm the missing data in count1 and count2?

```{r clean ex 2, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Add your code below

```
How about finding non-number values in count2?
```{r clean 5, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo3 %>% filter(!str_detect(count2,"^\\s*[0-9]*\\s*$"))
```

Or converting count2 to numeric. This will just force conversation, so we'll change that "None" into a proper `NA`:

```{r clean 6, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo3 %>% mutate(count2 = as.numeric(count2))
```

#### Renaming columns
Let's change that `cnont3` into something more seemly - like `count3`. I'll give you some tips, and then leave you to do the actual renaming as an exercise. We'll use the command `rename()` to do the renaming. It's a pretty simple command, so rather than explain it fully, let me refer you to the [manual page](https://dplyr.tidyverse.org/reference/rename.html) - or you can run `?rename()` in the R chunk below:


```{r clean ex 3, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
# Add your code below - I've included head(demo3) afterwards so that you can check the renaming has worked properly.


head(demo3)
```
Now that we have some data loaded and cleaned up, we're ready to use it to start writing our report.

## Updating text

As a refresher, let's have a look at the first few rows of the demo tibble using ```head()```, and also print out the total number of rows using ```nrow(demo_dates)```:

```{r update text 1, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
head(demo_dates)
nrow(demo_dates)
```

This data will change as the data in the demo.csv file changes. You can show yourself how this works as follows:

1. Knit this document now (menu at top middle of code pane or ctrl+shift+k)
2. Have a look at this section again - you should see that our original data has 68 rows
3. Now edit the demo.csv file. To do this, click on the demo.csv file in the `Files` pane, and select `View File`. This should open the data file in the code pane. 
4. Now delete a couple of rows of your choice, before saving and closing the file.
4. Now re-knit the document again. The data now has `r nrow(demo_dates)` rows, rather than the original 68 rows.

### Some ways of getting data into your report

The raw R output that we've been using so far is useful, but looks pretty nasty. Ideally, we'd like to be able to format this text so that it fits into our report properly.

#### Inline text

<!-- trying to get RMarkdown to actually display backticks is a faff that requires a workaround using \x60 as a synonym for the backtick symbol - so do please excuse the unintelligible symbols in this section-->

We can include R variables and data inline in our text by wrapping an R command in backticks: `` `r '\x60r some_command()\x60'` ``. 

When I first started using R, I don't think that I'd ever used the backtick (`` `r '\x60'` ``) key - usually at the extreme top left of most keyboards, often below the `Escape` key. Backticks are definitely different from the apostrophe ('), and it's important to not get the two confused when you're working with R.

If you haven't already, do follow along with the source code - particularly to find out how the last few commands are managed.

<!-- And note that we can write comments in our RMarkdown file which won't be displayed. This one is here to advise you to ignore the horrible messing about with \x60r etc that I've done in the paragraph below to get backticks to display properly in RMarkdown. -->

For example, we can count up all of the rows here, and by using the expression `` `r '\x60r nrow(demo_dates)\x60'` ``
find out that we have a total of `r nrow(demo_dates)` rows in our tibble. Or by wrapping the command `sum(demo_dates$count1)` we can add all the entries in the count1 column to give a total of `r sum(demo_dates$count1)`. Or `max(demo_dates$count3)` will let us discover that the maximum value in count3 is `r max(demo$count3)`. Or we can say that on the first day of this range (`r demo_dates[1,1]`), the value of count2 was `r demo_dates[1,3]`. Or that the mean (average) of count3 was `r round(mean(demo_dates$count3), 1)`.

<!-- The square brackets in demo[1,3] allow us to pull out data from specified places in a tibble. The general syntax is [row,column]. -->

#### Using knitr

Sometimes our reports need to contain larger chunks of data than are comfortable to manage using inline text. The most obvious example is the data table. We have some R commands that are extremely helpful for writing data tables in reports. `knitr::kable` is the most useful of all, because it allows us to produce nicely formatted tables with the very minimum of fooling about. So the first few rows of our demo tibble look like this:

```{r data table 1, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
knitr::kable(head(demo_dates))
```
I've included an example showing some of the other tweaks that might be useful to you with kable. I'd recommend having a look at ?kable to get a sense of the possible scope for tweaking tables in this way:

```{r data table 2, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
knitr::kable(head(demo_dates))
```

I'll say it again: **change the data, and all this stuff will update automatically**. For example, you might like to include a date in your report describing which month the data is about. You can do this easily: the latest date in this data comes from `r month(max(demo_dates$date), label=T, abbr=F)`. Change the data, re-knit the report, and bask in the glory of a updated report - go on, try it!

## Data processing
Most of the use that we get from data driven reports comes from the analysis that we do on the data. This is a very brief introduction to some basic analysis using R. We can do useful operations to our data like adding the columns together:

```{r processing 1, echo=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
demo_total <- demo_dates %>%
  mutate(total = count1 + count2 + count3) 

knitr::kable(head(demo_total))
```

Most of the details here should be familiar from previous parts. We use the pipe `>%>` to pass the `demo` tibble to `mutate`. `mutate` creates a new column (`total`) by adding together the three `count` columns, and we then assign our updated tibble to a new tibble named `demo_total`, which we display nicely via `knitr::kable`.

We can also summarise tables of data:

```{r processing 2, echo=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
knitr::kable(demo_total %>% summarise(across(where(is.numeric), ~round(mean(.x, na.rm=T)))))
```

That's a little bit harder to read, but breaks down nicely:

- we find the average of columns using `mean(.x, na.rm=T)`. The `.x` tells R to use whatever data is passed from the previous command, while the `na.rm=T` part tells R to ignore any missing data.
- `~round()` just rounds the mean values to the nearest whole number
- `across(where(is.numeric)` tells R that we want to use all the columns (so work `across()` all the columns) that contain numbers (`where(is.numeric)`)
- `summarise()` - crunch the results down into a single row
- `demo_total %>%` take the data in the `demo_total` tibble
- finally, `knitr::kable` displays a nice table containing the results

We can also add some extra instructions to `kable` to re-name the columns in our table to keep things clear for the reader of our report:

```{r processing 3, echo=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
knitr::kable(demo_total %>% summarise(across(where(is.numeric), ~round(mean(.x, na.rm=T)))), col.names = c("Mean of count 1", "Mean of count 2", "Mean of count 3", "Mean of total"))
```

We've added the line `col.names = c("Mean of count 1", "Mean of count 2", "Mean of count 3", "Mean of total")` just before the last bracket from the previous command. This tells kable to rename our table's columns to read properly.

**Question here about depth** Many many other kinds of data processing are possible, it's what R was built for. I worry though that this is getting too involved for an introductory session. Would like feedback - might consider breaking into a separate training resource here??

## Drawing graphs{.tabset}
Graphs are a really important part of report writing. There are lots of ways of drawing graphs in R, but the three that we'll demonstrate here are:

- a widely-used general purpose graph package called `ggplot2` for most common types of graph (bar, column, line, scatter...)
- an NHS-specific package called `NHSplotthedots` for producing XmR/run charts
- a diagram-drawing package called `DiagrammeR` which we'll use to draw a dynamic flowchart

### ggplot2 introduction
Let's start with a minimal example using our demo tibble:

```{r graph 1, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo_total) +
  geom_point(aes(x=count1, y=count2))

```

Here, the code works as follows:

- `ggplot(demo)` - we tell ggplot2 to use the `demo_total` tibble as a data source
- `geom_point` tells ggplot2 that we want an XY scatter plot
- the crux of the code is the `(aes(x=count1, y=count2))`. This tells R which columns in the `demo_total` tibble it should use to plot the points specified in `geom_point`
- finally, the `+` then chains together commands to produce a single plot

There are lots and lots of other `geom_xxx` options. A couple of commonly-used examples are geom_col and geom_line:

```{r, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo_total) +
  geom_col(aes(x=count1, y=count2))

```
```{r, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo_total) +
  geom_line(aes(x=count1, y=count2))

```

We can also add, using `+` other elements to ggplot2 graphs. Going back to our first XY scatter, we can add labels and regression lines as follows:

```{r graph 2, echo=TRUE, message=FALSE, warning=FALSE}

ggplot(demo_total) +
  geom_point(aes(x=count1, y=count2)) +
  geom_smooth(aes(x=count1, y=count2), method='lm') +
  labs(title="Scatter plot of count 1 against count 2 with linear regression") +
  ylab("Count 2") +
  xlab("Count 1")
```

### more advanced ggplot2
The secret to most useful visualisations is to get the data into the right format. Here's an example, based on using `dplyr` from the tidyverse to select parts of the data (i.e. excluding the total column), and then reformatting the demo tibble data. This allows ggplot2 to then plot counts for each day, using the `fill` option to set each type of count as a different colour.

```{r graph 3, echo=TRUE, message=FALSE, warning=FALSE}

demo_total %>%
  dplyr::select(!total) %>%
  pivot_longer(!date, names_to = "names", values_to = "count") %>%
  ggplot() +
  geom_col(aes(x=date, y=count, fill=names)) +
  labs(title = "Stacked bar of counts by date", fill="Count type") +
  xlab("Date") +
  ylab("Count")
```
Note that the changes to `demo_total` that we do in this command are only temporary - we don't ever assign the updated tibble anywhere. That's quite standard - I'd usually try and not make lots of different tibbles based on the same data, because it can get very confusing to try and remember which of `demo`, `demo_dates`, and `demo_total` we want to use. I'd suggest starting out by making new tibbles until you've built your speed and confidence up to the point where you become more comfortable doing the data work in a bespoke way for each of your visualisations etc.

### NHSplot the dots
(to add - or possibly not given the size of this thing)

### DiagrammeR
This is an interesting example of a very different kind of dynamic graph. Here, the structure of the graph remains the same, but the numerical counts will update as the data changes.

```{r graph 4, echo=TRUE, message=FALSE, warning=FALSE}
DiagrammeR::grViz("
digraph graph2 {

// a graph statement, which applies to the whole graph
graph [layout = dot]

// node statements, which describe how each of the nodes work. Note the @@x - corresponding to substituted label text below
node [shape = rectangle, width = 4, style = filled, fillcolor = beige]
a [label = '@@1']
b [label = '@@2']
c [label = '@@3']
d [label = '@@4']

// edge statements, which describe how each of the nodes are connected
a -> d
b -> d
c -> d

}

# Outside the main grViz bracket, the footnote-style substituted label text. [x] provides the text for @@x above.
[1]: paste0('Count 1 total (sum = ', sum(demo_total$count1), ')')
[2]: paste0('Count 2 total (sum = ', sum(demo_total$count2), ')')
[3]: paste0('Count 3 total (sum = ', sum(demo_total$count3), ')')
[4]: paste0('Total (sum = ', sum(demo_total$total), ')')
")

```

## More details

### Rmarkdown document settings

The easiest option is to start a new Rmarkdown document direct from the RStudio menu `File >> New file >> R Markdown...`. Alternatively, you can copy the header from this document, and paste it at the top of your document. Everything between the pair of three dashes: `---` is concerned with setting up this Rmarkdown document:

```{verbatim}
---
title: "![](https://i.imgur.com/5EhpPqK.png) Dynamic report demo"
date: "`r Sys.time()`"
output:
  html_document:
    toc: no
    toc_depth: 2
    number_sections: no
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '2'
    pandoc_args: ["--extract-media", "."]
  word_document:
    toc: yes
    toc_depth: '2'
---
```
You might notice that there are a couple of differences between the header from this document and the default version that RStudio gives you. I've added a link to the KIND Learning Network banner image as part of the title. If you're thinking about adapting this report to suit your purposes, you can easily change both of those by editing the URL (and the title text) in the following line:

```{verbatim}
title: "![](https://i.imgur.com/5EhpPqK.png) Dynamic report demo"
```

More info on [YAML editing in chapter 2 of the excellent R Markdown Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-anatomy.html).

Most of this header block is made up of options for the different output formats (html, word, and pdf). In RStudio, you can select which output format you'd like your report to be rendered as:

![](https://i.imgur.com/HhM3NqK.png)
Try these out now - this demo report should knit to each of the three formats without any problems. I'd recommend sticking with html while you're working on a report, though, just because it tends to render most quickly, and plays nicely with other aspects of the workflow while you're writing.

One thing to watch out for when tweaking these options: indentation and white-space matters. Each of the three output formats (html_document, pdf_document, and word_document) are indented from the *output:* line, and each of the output format options are indented too. A common cause of documents not knitting (see below) are small errors in the indenting in the header.

You might notice another tweak that I've made to the pdf output options for this document, which is to add the line:
```{verbatim}
    pandoc_args: ["--extract-media", "."]
```


### So what's next?

#### Alternatives
In the R/Rmarkdown universe, [Flexdashboard](https://pkgs.rstudio.com/flexdashboard/) looks great: there's an [example](https://www.themillerlab.io/post/flexdashboards/mcc_fake_cohort_dashboard_for_post.html#outcomes-by-stage) and a  [walkthrough by the Miller Lab](https://www.themillerlab.io/post/flexdashboards/)

### More on R code chunks

Code chunks in Rmarkdown start and end with a triple backtick:

![](https://i.imgur.com/o419Vw6.png)

There are then a few options that you can set for the code chunk. Here:

+ r: telling Rmarkdown to interpret this code as R. There are other languages that you can use in Rmarkdown, which is one of the strengths of building reports in this way.
+ setup: the chunk label. This can be anything you like, but no duplicates are allowed. Very useful for navigation in more complicated reports
+ echo=TRUE: whether to show this code in the report. If this is set to FALSE, you'll just see the output of the code (more on this below)
+ eval=TRUE: whether or not to run the code. If eval=FALSE, the code won't do anything other than appear in the report (useful if you're explaining how something works - like this report!)
+ warning = FALSE: whether to show warnings in the report if something goes wrong with your code
+ message=FALSE: whether to show information messages about how your code is running

Lots more info in the [Rmarkdown Cookbook](https://bookdown.org/yihui/rmarkdown/r-code.html)

you can also use `knitr::opts_chunk$set`, which is a really powerful way of managing chunk options - but that's a bit beyond the scope of this demo.