---
title: "![](https://i.imgur.com/5EhpPqK.png) Dynamic report demo"
date: "`r Sys.time()`"
output:
  html_document:
    toc: no
    toc_depth: 2
    number_sections: no
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '2'
    pandoc_args: ["--extract-media", "."]
  word_document:
    toc: yes
    toc_depth: '2'
---

# Introduction

This is an example of a dynamic report, written in [R](https://www.r-project.org/) and [Rmarkdown](http://rmarkdown.rstudio.com). It gives some example ways of automating common data-driven tasks. This report is intended as a starting point for automating your report writing processes. The idea is to replace (or speed up) manual report writing. The demo gives some basic introduction to the workflow. It then walks through a series of example tasks based on a toy data set. The demo also covers ways of producing the report in a variety of formats including pdf, Word document, and html webpage.

## Who is this demo for?
This demo is intended for someone who:

+ is currently spending lots of work time updating routine reports in health, care, or housing
+ **and** would like to reduce the time spent on this routine work over the medium-term (months)
+ **and** currently have the time to spend doing a complete overhaul of your report(s) 
+ **and** with a bit of coding experience **or** open to gaining some as part of this process
+ **and** with an hour or two now to work through this demo

## What this demo is not

+ it's not a full introduction to working in R/Rmarkdown. R is deep (like most analytic platforms), and this demonstration barely scratches the surface
+ it's not an introduction to everything that you might like to do with a data-driven report either. Instead, it covers some simple examples of common tasks as a way of familiarising you with a different workflow
+ it's definitely not a production-ready replacement for your existing reports. Instead, it's a learning resource, rather than a pre-packed replacement

## Is it worth it for me?

That's a metaphysical question!

+ Much harder the first time, and slower
+ So if you have regular reports, especially complicated ones with lots of graphs, deffo
+ Local IG concerns

## How does it work

[R](https://www.r-project.org/) is a programming language designed for statistical work

[Rmarkdown](http://rmarkdown.rstudio.com) is a simple markup language

Closely related to other kinds of markdown - you might well have used this before without really knowing what it was called. If you've ever posted on a wordpress site or web forum with basic text formatting options available, the chances are that you've already done at least a tiny bit of markdown. Just to give you an example, surrounding a word with asterisks formats it in *italics*. Or putting a dash before a word:

- puts it as a list item

This kind of very basic formatting is known as Markdown. While it's simple, it's usually sufficient to allow the production of neat and clear documents that are easy to ready. Rmarkdown is just Markdown with a few extras to allow you to embed R code directly into the text that you're writing. That R code allows you to do more-or-less any data analysis that you might like and include the results in your markdown-formatted document. If this is all new to you, you might like to have a quick look at some of the excellent introductory R/Rmarkdown resources:

+ [Rstudio's quick tour of Rmarkdown](https://rmarkdown.rstudio.com/authoring_quick_tour.html) is a great place to start if this is all new to you
+ If you're already somewhat familiar with working in R, you might prefer to start with the [Rmarkdown chapter in the *R for Data Science* book](https://r4ds.had.co.nz/r-markdown.html)

## What you need to work through the demo

+ working R and Rstudio installation **or**
+ access to a RStudio Cloud account

Easy to set-up and free for small-scale work. Likely not suitable for production work in health and care owing to information governance concerns, but by far the easiest way to get going from scratch if you've never worked with R before.

+ the source code for this report - [GitHub link](https://raw.githubusercontent.com/bclarke-nes/Dynamic-report-demo/master/demo.Rmd)
+ the demo data file [demo.csv](https://raw.githubusercontent.com/bclarke-nes/Dynamic-report-demo/master/demo.csv)
+ some experience of building reports manually
+ a good idea of what you'd like your report to do
+ time and space to complete the demo, and think about how it might be useful in your own practice

My suggestion would be not to try and use this demo to change your way of writing reports under pressure. There's quite a lot to think about here, and you might need to spend a good bit of time working out how to adapt this demonstration to fit your report. Think of this as the start of a journey, rather than a destination.

## Workflow overview

This demonstration will take you, step by step, through building a simple report in R and Rmarkdown. The big difference here from the usual way of building reports by hand is that you will combined the analysis, visualisation, and production stages of your report into a single step. As this demo will show, you can do all of this using R and Rmarkdown. You'll load the data, clean and analyse the data, and produce outputs (text, tables, graphs) straight into your report.


```{R message=FALSE, warning=FALSE,echo=F, fig.show='hold', out.width = "50%", fig.align = "default"}
DiagrammeR::mermaid("
graph TB

  data(get data)
  clean(clean up data)
  analyse(analyse, visualise, and report data)
  check(check - very important!)
  send(distribute the report)
  
data --> clean
clean --> analyse
analyse --> check
check --> send
")

```

# Starting an Rmarkdown document

There's a bit of preamble at the head of Rmarkdown documents that controls how they are built. For now, I'll suggest that you skip trying to figure it all out, and just use the header from this document. I'll give more details about setting up your Rmarkdown document at the end of this demo. 

Once you've got the header in place, we need to do a tiny bit of setting R up properly. 

```{r setup, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
  library(tidyverse)
  library(lubridate)
  library(NHSRplotthedots)
```

We load three packages (link to eventual NHS-R statement on tools and packages) here to help us do some useful work with our data. These are all *very* useful for health and care projects, so we'll briefly introduce them here:

+ [tidyverse](https://www.tidyverse.org/) - large ecosystem of tools designed for data science
+ [lubridate](https://lubridate.tidyverse.org/) - helps with handling dates and times
+ [NHSRplotthedots](https://github.com/nhs-r-community/NHSRplotthedots)  - NHS-R community tool for making XmR charts

You may need to install some or all of these packages. If you need to do this, you can add the line ```install.packages("PACKAGENAME")``` to your file, run that line (ctrl + enter), and then remove the line of code. Or install via ```Tools > Install packages...```.

Now that's working, we can skip ahead to the interesting part where we get some data into our project.

# Get data

This ~~feels~~ is easy to do in practice. Instead of opening a data file directly (as we might when using Excel), and then inspecting and analysing it, we instead load all the data in that file. We load the data using the following command:

```{r get data, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo <- read_csv("demo.csv") 
```

+ ```read_csv``` is the function that opens the .csv data file
+ ```demo.csv``` is the path to our data file
+ ```<-``` assigns the data that read_csv pulls out of the file to...
+ ```demo``` - the tibble that contains our data

Because there are lots of different types of data out there, there are lots of ways of loading data into R. ```read_csv``` is the most commonly-used one, because .csv files are widely used to share data. The other big one for this kind of work is tidyverse's ```read_excel```, which works similarly to ```read_csv```. Rather than explain how this works, I'll encourage you to read the relevant manual pages, which you can do with the command ```?read_excel``` (as before, run this using ctrl+enter in RStudio).

At the end of this process, we can have a look at the first few rows of our data using the ```head()``` command:

```{r inspect data 1, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
head(demo)
```
This is a tibble - the data structure used by the package ```tidyverse```. In this tibble (called ```demo```), each row contains a date, and three columns of count values from those dates. We can ask R to tell us other properties of ```demo``` too. For example, we can find the total number of rows with:

```{r inspect data 2, echo=TRUE, eval=TRUE, warning = FALSE, message=FALSE}
nrow(demo)
```

For now, though, there's an important problem with our tibble: our dates aren't proper dates yet. ```read_csv``` doesn't know that the values in the date column actually are dates. We can tell that by looking at the ```<<chr>>```, which stands for character, which is the way that R refers to text values. We want that to be a date, and doing that conversion will be our next exercise.

# Clean up data

Time for another R chunk:

```{r clean up data, echo=TRUE, eval=TRUE,warning = FALSE, message=FALSE}
demo <- demo %>% mutate(date = dmy(date))
```

There's a bit to unpack here. It makes most sense (to my mind, at least) to read this code backwards. From right to left, then:

+ ```dmy(date)```  is a lubridate command which takes whatever's in the bracket, and tries to convert it into a proper date. It works by assuming that it'll be a day value (d), followed by a month (m), followed by a year (y). There are also related commands like ```ymd()``` to be used when the dates given in our data are formatted differently.
+ ```mutate(date =...)``` takes the result of the ```dmy()``` above, and uses it in a tidyverse command ```mutate```. This is a really important and powerful tool, which makes new columns in tibbles from existing columns. Here, we tell ```mutate``` to make a new column called ```date``` by taking the result of the ```dmy(date)``` above.
+ ``` %>%``` [the pipe!](https://r4ds.had.co.nz/pipes.html) This is a way of chaining commands



# Getting text to update to reflect data

Let's have a look at the what's in demo.csv. We load this into the report in the setup chunk, using 

  ```
  demo <- read_csv("demo.csv") %>% mutate(date = dmy(date))
  ```
That gives us a tibble as follows:

`r knitr::kable(head(demo))`

(there are another `r nrow(demo) - 6` rows that I've cut out to save space).

This data will change as the data in the csv file changes. I'll encourage you to fiddle about with this, but if you're used to copy and pasting data tables about to update, this will be a great help.

We can also produce summary text inline. For example, we can count up all of the rows here, and say that we have a total of `r nrow(demo)` records. Or we can add all the entries in the count1 column (a total of `r sum(demo$count1)`). Or find out that the maximum value in count3 is `r max(demo$count3)`. Or we can say that on the first day of this range (`r demo[1,1]`), the value of count2 was `r demo[1,3]`. Or that the mean (average) of count3 was `r round(mean(demo$count3), 1)`.

I'll say it again: **change the data, and all this stuff will update automatically**. No need to copy and paste at many locations. For example, you might like to include a date in your report describing which month the data is about. You can do this easily: the latest date in this data comes from `r month(max(demo$date), label=T, abbr=F)`. Change the data, and this report will update - go on, try it!

# Doing data processing
We can do useful stuff like add the columns together:

```{r echo=FALSE, message=FALSE, warning=FALSE}
demo <- demo %>%
  mutate(total = count1 + count2 + count3) 

knitr::kable(head(demo))

```
(again, just showing the first few rows of data).

We can also summarise tables of data:

`r knitr::kable(demo %>% summarise(across(where(is.numeric), ~round(mean(.x, na.rm=T)))))`

or re-name columns in our tables:

`r knitr::kable(demo %>% summarise(across(where(is.numeric), ~round(mean(.x, na.rm=T)))), col.names = c("Mean of count 1", "Mean of count 2", "Mean of count 3", "Mean of total"))`


# Graphs
```{r echo=FALSE, message=FALSE, warning=FALSE}

ggplot(demo) +
  geom_point(aes(x=count1, y=count2)) +
  geom_smooth(aes(x=count1, y=count2), method='lm') +
  labs(title="Scatter plot of count 1 against count 2 with linear regression") +
  ylab("Count 2") +
  xlab("Count 1")


demo %>%
  dplyr::select(!total) %>%
  pivot_longer(!date, names_to = "names", values_to = "count") %>%
  ggplot() +
  geom_col(aes(x=date, y=count, fill=names)) +
  labs(title = "Stacked bar of counts by date", fill="Count type") +
  xlab("Date") +
  ylab("Count")

DiagrammeR::grViz("
digraph graph2 {

// a graph statement, which applies to the whole graph
graph [layout = dot]

// node statements, which describe how each of the nodes work. Note the @@x - corresponding to substituted label text below
node [shape = rectangle, width = 4, style = filled, fillcolor = beige]
a [label = '@@1']
b [label = '@@2']
c [label = '@@3']
d [label = '@@4']

// edge statements, which describe how each of the nodes are connected
a -> d
b -> d
c -> d

}

# Outside the main grViz bracket, the footnote-style substituted label text. [x] provides the text for @@x above.
[1]: paste0('Count 1 total (sum = ', sum(demo$count1), ')')
[2]: paste0('Count 2 total (sum = ', sum(demo$count2), ')')
[3]: paste0('Count 3 total (sum = ', sum(demo$count3), ')')
[4]: paste0('Total (sum = ', sum(demo$total), ')')
")

```

# Rmarkdown document settings

The easiest option is to start a new Rmarkdown document direct from the RStudio menu `File >> New file >> R Markdown...`. Alternatively, you can copy the header from this document, and paste it at the top of your document. Everything between the pair of three dashes: `---` is concerned with setting up this Rmarkdown document:

```{verbatim}
---
title: "![](https://i.imgur.com/5EhpPqK.png) Dynamic report demo"
date: "`r Sys.time()`"
output:
  html_document:
    toc: no
    toc_depth: 2
    number_sections: no
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '2'
    pandoc_args: ["--extract-media", "."]
  word_document:
    toc: yes
    toc_depth: '2'
---
```
You might notice that there are a couple of differences between the header from this document and the default version that RStudio gives you. I've added a link to the KIND Learning Network banner image as part of the title. If you're thinking about adapting this report to suit your purposes, you can easily change both of those by editing the URL (and the title text) in the following line:

```{verbatim}
title: "![](https://i.imgur.com/5EhpPqK.png) Dynamic report demo"
```

More info on [YAML editing in chapter 2 of the excellent R Markdown Cookbook](https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-anatomy.html).

Most of this header block is made up of options for the different output formats (html, word, and pdf). In RStudio, you can select which output format you'd like your report to be rendered as:

![](https://i.imgur.com/HhM3NqK.png)
Try these out now - this demo report should knit to each of the three formats without any problems. I'd recommend sticking with html while you're working on a report, though, just because it tends to render most quickly, and plays nicely with other aspects of the workflow while you're writing.

One thing to watch out for when tweaking these options: indentation and white-space matters. Each of the three output formats (html_document, pdf_document, and word_document) are indented from the *output:* line, and each of the output format options are indented too. A common cause of documents not knitting (see below) are small errors in the indenting in the header.

You might notice another tweak that I've made to the pdf output options for this document, which is to add the line:
```{verbatim}
    pandoc_args: ["--extract-media", "."]
```


# So what's next?

## Alternatives
In the R/Rmarkdown universe, [Flexdashboard](https://pkgs.rstudio.com/flexdashboard/) looks great: there's an [example](https://www.themillerlab.io/post/flexdashboards/mcc_fake_cohort_dashboard_for_post.html#outcomes-by-stage) and a  [walkthrough by the Miller Lab](https://www.themillerlab.io/post/flexdashboards/)

# More on R code chunks

Code chunks in Rmarkdown start and end with a triple backtick:

![](https://i.imgur.com/o419Vw6.png)

There are then a few options that you can set for the code chunk. Here:

+ r: telling Rmarkdown to interpret this code as R. There are other languages that you can use in Rmarkdown, which is one of the strengths of building reports in this way.
+ setup: the chunk label. This can be anything you like, but no duplicates are allowed. Very useful for navigation in more complicated reports
+ echo=TRUE: whether to show this code in the report. If this is set to FALSE, you'll just see the output of the code (more on this below)
+ eval=TRUE: whether or not to run the code. If eval=FALSE, the code won't do anything other than appear in the report (useful if you're explaining how something works - like this report!)
+ warning = FALSE: whether to show warnings in the report if something goes wrong with your code
+ message=FALSE: whether to show information messages about how your code is running

Lots more info in the [Rmarkdown Cookbook](https://bookdown.org/yihui/rmarkdown/r-code.html)

you can also use `knitr::opts_chunk$set`, which is a really powerful way of managing chunk options - but that's a bit beyond the scope of this demo.